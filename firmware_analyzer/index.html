<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Firmware Analyzer</title>
    <meta name="description" content="Upload and analyze firmware files for basic static analysis">
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .card {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            padding: 2rem;
            margin-bottom: 2rem;
        }
        #fileInput {
            margin-bottom: 1rem;
        }
        #analyzeBtn {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
        }
        #analyzeBtn:hover {
            background: #5a67d8;
        }
        #analyzeBtn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        #results {
            margin-top: 2rem;
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 5px;
            max-height: 400px;
            overflow-y: auto;
        }
        .section {
            margin-bottom: 1.5rem;
        }
        .section h3 {
            color: #667eea;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        .error {
            color: #dc3545;
        }
        .success {
            color: #28a745;
        }
        pre {
            background: #333;
            color: #fff;
            padding: 1rem;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="container">
            <h1>Firmware Analyzer</h1>
            <div class="card">
                <h2>Upload Firmware File</h2>
                <input type="file" id="fileInput" @change="handleFileSelect" accept=".bin,.img,.elf,.exe">
                <button @click="analyzeFirmware" :disabled="!selectedFile" id="analyzeBtn">Analyze Firmware</button>
            </div>

            <div v-if="analyzing" class="card">
                <p>Analyzing firmware... This may take a moment.</p>
            </div>

            <div v-if="results" class="card" id="results">
                <div v-for="section in Object.keys(results)" :key="section" class="section">
                    <h3>{{ section }}</h3>
                    <div v-if="section === 'Error'">
                        <p class="error">{{ results[section] }}</p>
                    </div>
                    <div v-else-if="section === 'File Info'">
                        <pre>{{ results[section] }}</pre>
                    </div>
                    <div v-else-if="section === 'Strings'">
                        <div v-for="str in results[section]" :key="str">
                            <code>{{ str }}</code><br>
                        </div>
                    </div>
                    <div v-else>
                        <pre>{{ JSON.stringify(results[section], null, 2) }}</pre>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@3.4.0/dist/vue.global.js"></script>
    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    selectedFile: null,
                    analyzing: false,
                    results: null
                }
            },

            methods: {
                handleFileSelect(event) {
                    this.selectedFile = event.target.files[0];
                    this.results = null;
                },

                async analyzeFirmware() {
                    if (!this.selectedFile) return;

                    this.analyzing = true;
                    this.results = null;

                    try {
                        const fileContent = await this.readFileAsArrayBuffer(this.selectedFile);
                        const analysis = this.performAnalysis(fileContent, this.selectedFile);
                        this.results = analysis;
                    } catch (error) {
                        this.results = { "Error": error.message };
                    } finally {
                        this.analyzing = false;
                    }
                },

                async readFileAsArrayBuffer(file) {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = () => reject(new Error('Failed to read file'));
                        reader.readAsArrayBuffer(file);
                    });
                },

                performAnalysis(arrayBuffer, file) {
                    const results = {};

                    // File Info
                    results['File Info'] = {
                        name: file.name,
                        size: file.size,
                        type: file.type || 'Unknown',
                        lastModified: new Date(file.lastModified).toLocaleString()
                    };

                    // Attempt to detect file type
                    const data = new Uint8Array(arrayBuffer);
                    const magic = data.slice(0, 16);
                    results['File Type Detection'] = this.detectFileType(magic, data);

                    // Extract strings
                    results['Strings'] = this.extractStrings(data);

                    // Basic hex dump (first 256 bytes)
                    results['Hex Dump (First 256 bytes)'] = this.hexDump(data.slice(0, 256));

                    // Basic entropy calculation
                    results['Entropy Analysis'] = this.calculateEntropy(data);

                    return results;
                },

                detectFileType(magic, data) {
                    const magicStr = Array.from(magic.slice(0, 4)).map(b => b.toString(16).padStart(2, '0')).join('').toUpperCase();

                    const signatures = {
                        '7F454C46': 'ELF Executable',
                        'CAFEBABE': 'Java Class',
                        '504B0304': 'ZIP Archive',
                        '52617221': 'RAR Archive',
                        '89504E47': 'PNG Image',
                        '4D5A9000': 'Windows PE'
                    };

                    return signatures[magicStr] || 'Unknown binary file';
                },

                extractStrings(data) {
                    const strings = [];
                    let current = '';
                    const minLength = 6;

                    for (let i = 0; i < data.length; i++) {
                        const char = data[i];
                        if (char >= 32 && char <= 126) { // Printable ASCII
                            current += String.fromCharCode(char);
                        } else {
                            if (current.length >= minLength) {
                                strings.push(current);
                            }
                            current = '';
                        }
                    }

                    // Last string
                    if (current.length >= minLength) {
                        strings.push(current);
                    }

                    return strings.slice(0, 100); // Limit to avoid overload
                },

                hexDump(data) {
                    let output = 'Offset | Hexadecimal                           | ASCII\n';
                    output += '-------|--------------------------------------|------\n';

                    for (let offset = 0; offset < data.length; offset += 16) {
                        const chunk = data.slice(offset, offset + 16);
                        const hex = Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(' ').padEnd(47, ' ');
                        const ascii = Array.from(chunk).map(b => (b >= 32 && b <= 126) ? String.fromCharCode(b) : '.').join('');

                        output += offset.toString(16).padStart(6, '0') + ' | ' + hex + ' | ' + ascii + '\n';
                    }

                    return output;
                },

                calculateEntropy(data) {
                    const counts = new Array(256).fill(0);
                    data.forEach(byte => counts[byte]++);

                    let entropy = 0;
                    const length = data.length;
                    counts.forEach(count => {
                        if (count > 0) {
                            const p = count / length;
                            entropy -= p * Math.log2(p);
                        }
                    });

                    return {
                        entropy: entropy.toFixed(4),
                        randomness: entropy < 6 ? 'Low' : entropy < 7 ? 'Medium' : 'High'
                    };
                }
            }
        }).mount('#app');

        // PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => console.log('SW registered'))
                    .catch(error => console.log('SW registration failed'));
            });
        }
    </script>
</body>
</html>
